"""
StarDiagram Content Generator

Orchestrates LLM content generation for star_diagram illustrations.
Auto-generated by Illustration Builder.
"""

import json
import logging
import time
from typing import Dict, Any, Optional, List
from app.llm_services.llm_service import get_gemini_service
from app.core.star_diagram_validator import get_validator

logger = logging.getLogger(__name__)


class StarDiagramGenerator:
    """Generates star_diagram content using LLM"""

    EXPECTED_FIELDS = ["element_1_label", "element_1_bullet_1", "element_1_bullet_2", "element_1_bullet_3", "element_2_label", "element_2_bullet_1", "element_2_bullet_2", "element_2_bullet_3", "element_3_label", "element_3_bullet_1", "element_3_bullet_2", "element_3_bullet_3", "element_4_label", "element_4_bullet_1", "element_4_bullet_2", "element_4_bullet_3", "element_5_label", "element_5_bullet_1", "element_5_bullet_2", "element_5_bullet_3"]

    def __init__(self):
        self.llm_service = get_gemini_service()
        self.validator = get_validator()

    async def generate_star_diagram_data(
        self,
        num_elements: int,
        topic: str,
        context: Dict[str, Any],
        target_points: Optional[List[str]] = None,
        tone: str = "professional",
        audience: str = "general",
        validate_constraints: bool = True,
        max_retries: int = 2
    ) -> Dict[str, Any]:
        """
        Generate star_diagram content with LLM.

        Args:
            num_elements: Number of elements in the illustration
            topic: Main topic for content generation
            context: Additional context (industry, previous_slides, etc.)
            target_points: Key points to include
            tone: Writing tone (professional, casual, technical)
            audience: Target audience
            validate_constraints: Whether to validate character limits
            max_retries: Max retry attempts on validation failure

        Returns:
            Dict with generated content, validation results, and metadata
        """
        start_time = time.time()
        constraints = self.validator.get_constraints_for_variant(num_elements)

        # Build prompt for LLM
        prompt = self._build_prompt(
            topic=topic,
            num_elements=num_elements,
            context=context,
            constraints=constraints,
            target_points=target_points,
            tone=tone,
            audience=audience
        )

        for attempt in range(max_retries + 1):
            logger.info(f"Generating star_diagram content (attempt {attempt + 1}/{max_retries + 1})")

            try:
                # Call LLM service (using generate_content with JSON format)
                result = await self.llm_service.generate_content(
                    prompt=prompt,
                    response_format="json"
                )

                if not result.get("success"):
                    continue

                generated_content = result.get("content", {})

                # Validate if required
                if validate_constraints:
                    is_valid, violations = self.validator.validate_content(
                        generated_content, num_elements
                    )
                    if is_valid:
                        logger.info("Content validation passed")
                        break
                    else:
                        logger.warning(f"Validation failed: {len(violations)} violations")
                        if attempt < max_retries:
                            continue
                else:
                    is_valid = True
                    violations = []
                    break

            except Exception as e:
                logger.error(f"Generation attempt {attempt + 1} failed: {e}")
                if attempt == max_retries:
                    return {
                        "success": False,
                        "error": str(e)
                    }

        character_counts = self.validator.get_character_counts(generated_content, num_elements)
        generation_time = int((time.time() - start_time) * 1000)

        return {
            "success": True,
            "content": generated_content,
            "character_counts": character_counts,
            "validation": {
                "valid": is_valid,
                "violations": violations
            },
            "metadata": {
                "generation_time_ms": generation_time,
                "attempts": attempt + 1,
                "model": result.get("model", "gemini-2.0-flash-exp"),
                "usage": result.get("usage_metadata", {})
            }
        }

    def _build_prompt(
        self,
        topic: str,
        num_elements: int,
        context: Dict,
        constraints: Dict,
        target_points: Optional[List[str]],
        tone: str,
        audience: str
    ) -> str:
        """Build the LLM prompt for content generation"""

        # Build constraint description
        constraint_desc = []
        for element_id, element_constraints in constraints.items():
            if isinstance(element_constraints, dict):
                for field, limits in element_constraints.items():
                    if isinstance(limits, dict) and "max" in limits:
                        constraint_desc.append(
                            f"- {element_id}_{field}: {limits['min']}-{limits['max']} characters"
                        )

        constraints_text = "\n".join(constraint_desc) if constraint_desc else "No specific constraints"

        target_points_text = ""
        if target_points:
            target_points_text = f"\n\nKey points to address:\n" + "\n".join(f"- {p}" for p in target_points)

        return f"""Generate content for a "Star Diagram" illustration about: {topic}

Tone: {tone}
Audience: {audience}
Number of elements: {num_elements}
{target_points_text}

Additional context: {json.dumps(context) if context else 'None'}

Return a JSON object with the following fields:
{", ".join(self.EXPECTED_FIELDS)}

CRITICAL REQUIREMENTS:
1. Labels: 1-2 words only (5-20 characters)
2. Bullets: EXACTLY 35-40 characters (excluding <strong> tags)
   - Count only visible text, NOT the HTML tags
   - Each bullet must have ONE key phrase in <strong> tags

CORRECT bullet examples (35-40 chars visible text):
- "Develop <strong>new strategies</strong> for growth" (35 chars = GOOD)
- "Create <strong>measurable outcomes</strong> with data" (38 chars = GOOD)
- "Drive <strong>innovation</strong> across all teams" (35 chars = GOOD)
- "Build <strong>customer trust</strong> via fast delivery" (40 chars = GOOD)

WRONG (too short or too long):
- "Build <strong>trust</strong> via delivery" (26 chars = TOO SHORT)
- "Build customer trust through consistent reliable delivery" (50 chars = TOO LONG)

Keep bullets punchy and impactful. Every word must earn its place.
"""


# Global generator instance
_generator: StarDiagramGenerator = None


def get_generator() -> StarDiagramGenerator:
    """Get or create the global generator instance"""
    global _generator
    if _generator is None:
        _generator = StarDiagramGenerator()
    return _generator
